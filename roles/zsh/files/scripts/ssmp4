#!/bin/bash

# This script finds the most recently modified file in the specified
# screenshot directory and converts it to an MP4 using ffmpeg.

# --- Configuration ---
# Define the directory where your screenshots are stored.
# "$HOME" is a standard environment variable pointing to your home directory.
SCREENSHOT_DIR="$HOME/Pictures/Screenshots"

# Define the output directory for the MP4 file.
# By default, it will save the MP4 in the same directory as the screenshot.
# Uncomment and modify the line below if you want to save it elsewhere.
# OUTPUT_DIR="$HOME/Videos/ConvertedScreenshots"

# --- Pre-checks ---
# Check if the screenshot directory exists.
if [ ! -d "$SCREENSHOT_DIR" ]; then
  echo "Error: Screenshot directory not found at '$SCREENSHOT_DIR'."
  echo "Please ensure the path is correct or create the directory."
  exit 1
fi

# Check if ffmpeg is installed and available in the system's PATH.
if ! command -v ffmpeg &> /dev/null; then
  echo "Error: ffmpeg is not installed or not found in your PATH."
  echo "Please install ffmpeg to use this script."
  echo "  - On macOS (with Homebrew): brew install ffmpeg"
  echo "  - On Ubuntu/Debian: sudo apt update && sudo apt install ffmpeg"
  exit 1
fi

# --- Find the most recent file (compatible with macOS and Linux) ---
# This method uses `find` to list files, `stat` to get modification times,
# `sort` to order them, and `head` to pick the newest.
# It's robust against filenames containing spaces or special characters.

# The `stat` command syntax differs slightly between macOS (BSD stat) and Linux (GNU stat).
# We'll use a conditional check to determine the correct stat format.
if [[ "$(uname)" == "Darwin" ]]; then
  # macOS (BSD stat) format: %m for modification time, %N for filename
  STAT_FORMAT="%m %N"
else
  # Linux (GNU stat) format: %Y for modification time, %n for filename
  STAT_FORMAT="%Y %n"
fi

echo "Searching for the most recent file in '$SCREENSHOT_DIR'..."

# Find all files, print their modification time and path, sort by time, get the newest.
# `find ... -print0` ensures null-separated output for robust handling of spaces.
# `xargs -0 stat ...` applies stat to each found file.
# `sort -rn` sorts numerically and in reverse (newest first).
# `head -n 1` gets only the top (newest) result.
# `cut -f2- -d' '` extracts the filename/path by removing the timestamp.
RECENT_FILE=$(find "$SCREENSHOT_DIR" -maxdepth 1 -type f -print0 | \
               xargs -0 stat -f "$STAT_FORMAT" 2>/dev/null | \
               sort -rn | head -n 1 | \
               cut -f2- -d' ')

# Check if a file was found.
if [ -z "$RECENT_FILE" ]; then
  echo "Error: No files found in '$SCREENSHOT_DIR'."
  exit 1
fi

echo "Most recent file found: '$RECENT_FILE'"

# --- Determine output filename and path ---
# Extract the base filename (e.g., "MyScreenshot.png")
FILENAME=$(basename "$RECENT_FILE")
# Remove the file extension to get just the name (e.g., "MyScreenshot")
FILENAME_NO_EXT="${FILENAME%.*}"

# Construct the full path for the output MP4 file.
# By default, it's saved in the same directory as the input screenshot.
OUTPUT_MP4="${SCREENSHOT_DIR}/${FILENAME_NO_EXT}.mp4"

# If OUTPUT_DIR was uncommented and set, use it.
# This block handles creating the output directory if it doesn't exist.
if [ -n "${OUTPUT_DIR+x}" ]; then # Check if OUTPUT_DIR is set (not just empty)
  OUTPUT_MP4="${OUTPUT_DIR}/${FILENAME_NO_EXT}.mp4"
  if [ ! -d "$OUTPUT_DIR" ]; then
    echo "Creating output directory: '$OUTPUT_DIR'"
    mkdir -p "$OUTPUT_DIR" || { echo "Error: Could not create output directory."; exit 1; }
  fi
fi

echo "Output MP4 will be saved to: '$OUTPUT_MP4'"

# --- Run ffmpeg conversion ---
echo "Starting ffmpeg conversion..."
echo "Input: '$RECENT_FILE'"
echo "Output: '$OUTPUT_MP4'"

# ffmpeg command with recommended settings for broad compatibility and good quality.
# -i "$RECENT_FILE": Specifies the input file.
# -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2": Ensures video dimensions are even,
#                                         which is a common requirement for many codecs.
# -pix_fmt yuv420p: Sets the pixel format to YUV 4:2:0, highly compatible with most players.
# -c:v libx264: Uses the H.264 video codec, widely supported and efficient.
# -preset medium: Balances encoding speed and file size/quality. Other options: ultrafast, fast, slow, etc.
# -crf 23: Constant Rate Factor for quality. Lower values = higher quality, larger file.
#          23 is a good general-purpose value. Range is 0 (lossless) to 51 (worst).
# -y: Overwrite the output file without asking if it already exists.
ffmpeg -i "$RECENT_FILE" \
       -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" \
       -pix_fmt yuv420p \
       -c:v libx264 \
       -preset medium \
       -crf 23 \
       -y \
       "$OUTPUT_MP4"

# --- Post-conversion check ---
# Check the exit status of the ffmpeg command.
if [ $? -eq 0 ]; then
  echo "----------------------------------------------------"
  echo "Conversion successful! MP4 saved to: '$OUTPUT_MP4'"
  echo "----------------------------------------------------"
else
  echo "----------------------------------------------------"
  echo "Error: ffmpeg conversion failed."
  echo "Please check the ffmpeg output above for details."
  echo "----------------------------------------------------"
  exit 1
fi

exit 0
